name: Windows RDP via Cloudflare Tunnel

on:
  workflow_dispatch:

jobs:
  rdp:
    runs-on: windows-latest
    env:
      RDP_USERNAME: ${{ secrets.RDP_USERNAME }}
      RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
      RDP_SUBDOMAIN: ${{ secrets.RDP_SUBDOMAIN }}
      CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
      TUNNEL_NAME: ${{ secrets.TUNNEL_NAME }}

    steps:
      - name: Show basic info
        shell: pwsh
        run: |
          Write-Host "Starting Windows RDP setup via Cloudflare Tunnel..."
          Write-Host "Target subdomain: $env:RDP_SUBDOMAIN"

      - name: Enable RDP & Firewall
        shell: pwsh
        run: |
          Write-Host "Enabling RDP and firewall rules..."
          Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 0
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
          Write-Host "RDP and firewall configured."

      - name: Create RDP user (PowerShell robust)
        shell: pwsh
        run: |
          if ($env:RDP_USERNAME -match '^(Administrators|Users|Guests|DefaultAccount|WDAGUtilityAccount)$') {
            Write-Error "RDP_USERNAME appears to be a reserved account/group name. Choose a different username."
            exit 1
          }

          $existing = Get-LocalUser -Name $env:RDP_USERNAME -ErrorAction SilentlyContinue
          if ($existing) {
            Write-Host "User '$($env:RDP_USERNAME)' already exists. Skipping creation."
          } else {
            $securePass = ConvertTo-SecureString $env:RDP_PASSWORD -AsPlainText -Force
            try {
              New-LocalUser -Name $env:RDP_USERNAME -Password $securePass -FullName $env:RDP_USERNAME -PasswordNeverExpires -AccountNeverExpires
              Write-Host "User '$($env:RDP_USERNAME)' created."
            } catch {
              Write-Error "Failed to create user: $($_.Exception.Message)"
              exit 1
            }
          }

          $isMember = Get-LocalGroupMember -Group "Administrators" -Member $env:RDP_USERNAME -ErrorAction SilentlyContinue
          if ($isMember) {
            Write-Host "User is already a member of Administrators."
          } else {
            try {
              Add-LocalGroupMember -Group "Administrators" -Member $env:RDP_USERNAME
              Write-Host "Added user to Administrators group."
            } catch {
              Write-Error "Failed to add user to Administrators: $($_.Exception.Message)"
              exit 1
            }
          }

      - name: Install cloudflared and locate executable
        shell: pwsh
        run: |
          Write-Host "Installing cloudflared (MSI)..."
          $msi = "cloudflared.msi"
          Invoke-WebRequest -Uri "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.msi" -OutFile $msi
          Start-Process msiexec.exe -ArgumentList "/i $msi /quiet /norestart" -Wait

          Write-Host "Attempt to locate cloudflared executable..."

          # Common candidate locations
          $candidates = @(
            "`$env:ProgramFiles\Cloudflare\Cloudflared\cloudflared.exe".Replace('`$env:ProgramFiles',$env:ProgramFiles),
            "`$env:ProgramFiles\Cloudflare\cloudflared\cloudflared.exe".Replace('`$env:ProgramFiles',$env:ProgramFiles),
            "`$env:ProgramFiles\cloudflared\cloudflared.exe".Replace('`$env:ProgramFiles',$env:ProgramFiles),
            "`$env:ProgramFiles(x86)\Cloudflare\Cloudflared\cloudflared.exe".Replace('`$env:ProgramFiles(x86)',$env:ProgramFiles(x86)),
            "$env:LOCALAPPDATA\Programs\cloudflared\cloudflared.exe",
            "$env:USERPROFILE\cloudflared\cloudflared.exe"
          )

          $found = $null
          foreach ($p in $candidates) {
            if ($p -and (Test-Path $p)) {
              $found = $p
              break
            }
          }

          # Try where.exe (if MSI added to PATH)
          if (-not $found) {
            try {
              $where = (where.exe cloudflared 2>$null) -split "`r?`n" | Select-Object -First 1
              if ($where -and (Test-Path $where)) { $found = $where }
            } catch { }
          }

          # Last resort: limited recursive search (first N matches)
          if (-not $found) {
            Write-Host "Doing a limited recursive search for cloudflared.exe (may take a few seconds)..."
            # Search common root folders to limit runtime
            $roots = @("C:\Program Files", "C:\Program Files (x86)", "C:\Users")
            foreach ($r in $roots) {
              try {
                $hit = Get-ChildItem -Path $r -Filter cloudflared.exe -Recurse -ErrorAction SilentlyContinue -Force | Select-Object -First 1
                if ($hit) { $found = $hit.FullName; break }
              } catch { }
            }
          }

          if (-not $found) {
            Write-Error "Could not locate cloudflared.exe after installation. List common dirs for debugging:"
            Write-Host "ProgramFiles: $env:ProgramFiles"
            Write-Host "ProgramFiles(x86): $env:ProgramFiles(x86)"
            Write-Host "LOCALAPPDATA: $env:LOCALAPPDATA"
            exit 1
          }

          Write-Host "Found cloudflared at: $found"
          # Export for subsequent steps
          echo "CLOUDFLARED_PATH=$found" >> $env:GITHUB_ENV
          # ensure session PATH includes the folder
          $folder = Split-Path $found -Parent
          $env:PATH = "$env:PATH;$folder"
          Write-Host "cloudflared version:"
          & $found --version

      - name: Login cloudflared using API token
        shell: pwsh
        run: |
          $cloudflared = $env:CLOUDFLARED_PATH
          if (-not $env:CF_API_TOKEN) { Write-Error "CF_API_TOKEN not set"; exit 1 }
          if (-not (Test-Path $cloudflared)) { Write-Error "cloudflared not found at $cloudflared"; exit 1 }
          Write-Host "Logging in cloudflared with token..."
          & $cloudflared login --token $env:CF_API_TOKEN
          Write-Host "Login completed."

      - name: Ensure tunnel exists
        shell: pwsh
        run: |
          $cloudflared = $env:CLOUDFLARED_PATH
          $name = $env:TUNNEL_NAME
          if (-not $name) { Write-Error "TUNNEL_NAME not set"; exit 1 }

          Write-Host "Checking existing tunnels..."
          $list = & $cloudflared tunnel list 2>&1
          if ($LASTEXITCODE -ne 0) { Write-Host "Warning: tunnel list returned non-zero exit code. Output:"; Write-Host $list }

          if ($list -and ($list -match [regex]::Escape($name))) {
            Write-Host "Tunnel '$name' already exists. Skipping creation."
          } else {
            Write-Host "Creating tunnel '$name'..."
            $createOut = & $cloudflared tunnel create $name 2>&1
            if ($LASTEXITCODE -ne 0) {
              Write-Host $createOut
              if ($createOut -match 'already exists' -or $createOut -match 'conflict') {
                Write-Host "Tunnel already exists. Continuing."
              } else { exit 1 }
            } else { Write-Host "Tunnel created." }
          }

      - name: Ensure DNS route exists
        shell: pwsh
        run: |
          $cloudflared = $env:CLOUDFLARED_PATH
          $name = $env:TUNNEL_NAME
          $host = $env:RDP_SUBDOMAIN
          if (-not $host) { Write-Error "RDP_SUBDOMAIN not set"; exit 1 }

          Write-Host "Creating DNS route..."
          $routeOut = & $cloudflared tunnel route dns $name $host 2>&1
          if ($LASTEXITCODE -ne 0) {
            Write-Host $routeOut
            if ($routeOut -match 'already exists' -or $routeOut -match 'already have a record') {
              Write-Host "DNS route already exists. Continuing."
            } else { Write-Host "Warning: DNS route may need manual creation in Cloudflare dashboard." }
          } else { Write-Host "DNS route created." }

      - name: Run tunnel and expose RDP (foreground)
        shell: pwsh
        run: |
          $cloudflared = $env:CLOUDFLARED_PATH
          $name = $env:TUNNEL_NAME
          Write-Host "Starting cloudflared tunnel '$name' for RDP (rdp://localhost:3389)..."
          & $cloudflared tunnel run $name --url rdp://localhost:3389

      - name: Show access info
        shell: pwsh
        run: |
          Write-Host "===================================================="
          Write-Host "RDP should be available at: $env:RDP_SUBDOMAIN"
          Write-Host "Username: $env:RDP_USERNAME"
          Write-Host "Password: (secret)"
          Write-Host "Reminder: GitHub Actions runner is temporary â€” not 24/7."
          Write-Host "To stop the tunnel, cancel this workflow run."
          Write-Host "===================================================="
